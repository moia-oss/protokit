package utils

import (
	"os"

	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/dynamicpb"
	"google.golang.org/protobuf/types/pluginpb"

	"errors"
	"path/filepath"
)

// CreateGenRequest creates a codegen request from a `FileDescriptorSet`
func CreateGenRequest(fds *descriptorpb.FileDescriptorSet, filesToGen ...string) *pluginpb.CodeGeneratorRequest {
	files := RegisterExtensions(fds)
	req := new(pluginpb.CodeGeneratorRequest)
	req.ProtoFile = files

	for _, f := range req.GetProtoFile() {
		if InStringSlice(filesToGen, f.GetName()) {
			req.FileToGenerate = append(req.FileToGenerate, f.GetName())
		}
	}

	return req
}

// FilesToGenerate iterates through the proto files in the request and returns only the ones that were requested on the
// command line. Only these protos should be generated by a codegen plugin.
func FilesToGenerate(req *pluginpb.CodeGeneratorRequest) []*descriptorpb.FileDescriptorProto {
	protos := make([]*descriptorpb.FileDescriptorProto, 0)

OUTERLOOP:
	for _, name := range req.GetFileToGenerate() {
		for _, f := range req.GetProtoFile() {
			if f.GetName() == name {
				protos = append(protos, f)
				continue OUTERLOOP
			}
		}
	}

	return protos
}

// LoadDescriptorSet loads a `FileDescriptorSet` from a file on disk. Such a file can be generated using the
// `--descriptor_set_out` flag with `protoc`.
//
// Example:
//
//	protoc --descriptor_set_out=fileset.pb --include_imports --include_source_info ./booking.proto ./todo.proto
func LoadDescriptorSet(pathSegments ...string) (*descriptorpb.FileDescriptorSet, error) {
	f, err := os.ReadFile(filepath.Join(pathSegments...))
	if err != nil {
		return nil, err
	}

	set := new(descriptorpb.FileDescriptorSet)
	if err = proto.Unmarshal(f, set); err != nil {
		return nil, err
	}

	return set, nil
}

// FindDescriptor finds the named descriptor in the given set. Only base names are searched. The first match is
// returned, on `nil` if not found
func FindDescriptor(set *descriptorpb.FileDescriptorSet, name string) *descriptorpb.FileDescriptorProto {
	for _, pf := range set.GetFile() {
		if filepath.Base(pf.GetName()) == name {
			return pf
		}
	}

	return nil
}

// LoadDescriptor loads file descriptor protos from a file on disk, and returns the named proto descriptor. This is
// useful mostly for testing purposes.
func LoadDescriptor(name string, pathSegments ...string) (*descriptorpb.FileDescriptorProto, error) {
	set, err := LoadDescriptorSet(pathSegments...)
	if err != nil {
		return nil, err
	}

	if pf := FindDescriptor(set, name); pf != nil {
		return pf, nil
	}

	return nil, errors.New("FileDescriptor not found")
}

func RegisterExtensions(fds *descriptorpb.FileDescriptorSet) []*descriptorpb.FileDescriptorProto {
	extTypes := new(protoregistry.Types)

	files, err := protodesc.NewFiles(fds)
	if err != nil {
		panic(err)
	}

	files.RangeFiles(func(fileDescriptor protoreflect.FileDescriptor) bool {
		err := registerAllExtensions(extTypes, fileDescriptor)
		if err != nil {
			panic(err)
		}
		return true
	})

	new_files := make([]*descriptorpb.FileDescriptorProto, 0)
	for _, fd := range fds.GetFile() {
		b, _ := proto.Marshal(fd)
		err := proto.UnmarshalOptions{Resolver: extTypes}.Unmarshal(b, fd)
		if err != nil {
			panic(err)
		}
		new_files = append(new_files, fd)
	}

	return new_files
}

func registerAllExtensions(extTypes *protoregistry.Types, descs interface {
	Messages() protoreflect.MessageDescriptors
	Extensions() protoreflect.ExtensionDescriptors
}) error {
	mds := descs.Messages()
	for i := 0; i < mds.Len(); i++ {
		err := registerAllExtensions(extTypes, mds.Get(i))
		if err != nil {
			return err
		}
	}
	xds := descs.Extensions()
	for i := 0; i < xds.Len(); i++ {
		if err := extTypes.RegisterExtension(dynamicpb.NewExtensionType(xds.Get(i))); err != nil {
			return err
		}
	}
	return nil
}
